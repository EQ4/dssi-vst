
dssi-vst: a DSSI plugin wrapper for VST plugins
===============================================

This is a provisional implementation of a DSSI plugin wrapper for VST
effects and instruments with GUI support.

Source files:

* dssi-vst.cpp: DSSI plugin implementation (works OK mostly)
* dssi-vst_gui.cpp: DSSI plugin GUI process implementation (not done yet)
* dssi-vst-scanner.cpp: Program that determines what VSTs you have (a bit
  like fstconfig in the fst package) and communicates it back to the plugin
* dssi-vst-server.cpp: Program that hosts a single VST with a comms link
  to the plugin (a bit like a less general version of Kjetil's vstserver)
* rdwrops.cpp, paths.cpp: misc functions
* remotepluginclient.cpp/remotepluginserver.cpp: Code to handle process
  separation for audio plugin (not VST specific), used by DSSI plugin & server
* vstsyth.cpp: JACK/aseq host for VSTs using dssi-vst-server, but not using
  the actual DSSI plugin.  Mostly for test purposes, this does nothing you
  can't already do better with vstserver or jack_fst.

Copyright (c) 2004 Chris Cannam.


Build etc
---------

To build dssi-vst, you will need:

* A reasonably recent version of Wine (anything from the start of 2004
  onwards is probably OK) -- http://www.winehq.com/

* Steve Harris's liblo "Lite OSC" library -- http://liblo.sf.net/.
  You will need version 0.6 or newer, but unfortunately versions 0.6-0.8
  contain a serious bug that prevents DSSI GUI startup from working.  So
  look out for 0.9 (not actually released at the time of writing!)

* The VST SDK headers -- http://www.steinberg.net/steinberg/ygrabit/index.html
  These are free but not redistributable.

Once you have all of the above, edit Makefile.in to specify the VST
SDK location; then you should be able to build and install by running
autoconf ; ./configure ; make ; make install.

To use dssi-vst: make sure DSSI_PATH is set appropriately, set
VST_PATH to a colon-separated list of the directories containing VST
plugins, and start up your DSSI host.

The plugin soname is dssi-vst.so, and each VST plugin gets a label
corresponding to its DLL name.  So for example, with
dssi_example_host, you should be able to just run dssi_example_host
dssi-vst.so MyVstPlugin.dll.

NB: dssi-vst does not handle multiple VST plugins in a single DLL.


Why not use vstserver or libfst?
--------------------------------

dssi-vst doesn't use libfst because libfst is just too serious a thing
to start messing about with in a plugin whose host doesn't know about
it (because it involves introducing Wine threads into the host).

Architecturally dssi-vst is a little bit like vstserver in that it
runs the plugin in a separate process and communicates with it via
some IPC mechanism (here shared memory and POSIX FIFOs, where
vstserver uses shared memory and Unix domain sockets).  The big
difference is that dssi-vst spawns a separate process per plugin
rather than using a single server.  To be honest, the only practical
reason dssi-vst doesn't use vstserver is that I wrote most of this
code quite a while ago as an exercise, and I've just got used to my
own code.

These are some of the theoretical good points of dssi-vst's
architecture:

* Bugs in dssi-vst aside, it ought to be impossible for a misbehaving
  VST plugin to crash its host, for a misbehaving plugin GUI to
  disrupt either the host or the audio part of the plugin (because
  the GUI and audio parts are in separate processes), or for one
  misbehaving plugin or plugin GUI to disrupt another.  It's therefore
  theoretically possible for dssi-vst to be more stable for audio use
  than either an fst host or vstserver.

* Because there is no real audio work done in the GUI process and
  no requirement for an audio thread, the GUI code is less likely to
  experience problems from thread mismanagement.

* DSSI provides a closer match to the VST feature set than LADSPA
  does -- apart from the synth stuff, this plugin handles VST programs
  as well as parameters -- which makes it more useful than vstserver's
  LADSPA wrapper plugin.

* Obviously, dssi-vst allows any DSSI host to become a VST host
  without having to know anything about VST or to have a code (or
  licence) dependency on the VST SDK, which is not the case with fst.

* Marginally simpler than vstserver to use, because you don't have to
  start the server yourself.

Bad points:

* Processes everywhere.  Besides your host process, you get a
  server process to do the actual audio processing, a scanner
  process to identify the available VST plugins, and a GUI process
  to run the GUI -- and all of these are winelib applications that
  are run under Wine.  dssi-vst is useful for running the odd synth
  or effect on a fast machine, not for doing all your effects work.

* A plugin with a visible GUI actually has to be instantiated twice.
  The GUI instantiation doesn't do the full audio processing work,
  and it isn't created unless you actually want to see the GUI, but
  this is still wasteful of resources.

* Any plugin GUI that uses its own back channel to communicate
  directly with the plugin will fail, because there's no way to
  intercept this information, which is necessary for the DSSI GUI
  separation model.  The most obvious example where this causes
  failures is for synth plugins with miniature keyboards or test
  buttons built into their GUIs: these gizmos cannot work with
  dssi-vst, although that doesn't usually prevent the plugin
  itself from working.  More complex plugins with complex GUIs
  that do patch management in the plugin GUI also suffer, though
  they might be better run as standalone jack_fst or vstserver
  applications plumbed into the JACK graph anyway.

* It's hard to make sure things like the communications FIFOs are
  tidied up when exiting.  Apart from anything else it requires
  that the host call cleanup() on its plugins when exiting from
  ctrl-C or whatever.  This isn't quite handled satisfactorily yet
  either in this code or in the existing hosts.  A vstserver model
  can cope better with this by having the server take ownership
  of such resources instead of the plugin.

* The comms model dssi-vst uses introduces a fixed latency equal to
  the JACK period size, as well as any existing latency in the VST
  plugin.  (The fixed latency is exposed through the _latency output
  control port.  Does anyone know how to find out the latency of a
  VST plugin?)


Licence
-------

My usual preference would be to offer dssi-vst under the GNU GPL.
However, it is my personal belief that GPL'd code that makes use of
the Steinberg VST SDK header files cannot be distributed without
violating either the GPL or at least one of the copyright or licensing
terms for the Steinberg header files.  So I am offering this code
under the following terms:

You may distribute and/or modify dssi-vst under the terms of version 2
of the GNU General Public License as published by the Free Software
Foundation, except that you are hereby permitted to omit the source
code to the two VST SDK header files AEffect.h and aeffectx.h (the
source code of which would otherwise be required by section 3 of the
GPL) when redistributing dssi-vst.  The full terms of the GPL continue
to apply to all of the remaining source code for dssi-vst.

Chris Cannam
cannam@all-day-breakfast.com


Licence for liblo
-----------------

dssi-vst makes use of the liblo library by Steve Harris, which is
provided under the GPL.  Steve Harris has provided the following
exemption to permit the liblo library to be used with dssi-vst:

You are hereby permitted to omit the source code to the two VST SDK
header files AEffect.h and aeffectx.h (the source code of which would
otherwise be required by section 3 of the GPL) when redistributing any
version of dssi-vst which uses liblo.  This offer does not imply any
exemption to the GPL for the liblo code itself or the remainder of
dssi-vst, nor to any other derived work that may use liblo.

Steve Harris
steve <at> plugin <dot> org <dot> uk

